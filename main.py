def reflector(expression: list[int], n: int) -> list[int]:
    """We follow the algorithm in the Leclerc paper on cluster structures in
    strata of Grassmannians and treat a:list[int] as the indices for a reduced
    expression of the permutation w.
    We start by considering the fundamental weight omega_a[-1]. We then act by the reflection a[-1].
    This gives omega_a[-1] + alpha_a[-1].
    We then delete a[-1] and apply the new a[-1] to this sum as a reflection until the list is empty.
    We assume we are in type A. The integer n records the number of vertices.
    """
    a = expression.copy()
    for i in range(len(a)):
        a[i] -= 1
    root = a[-1]
    counter = [0 for _ in range(n)]
    while len(a) > 0:
        counter[a[-1]] = -counter[a[-1]]
        if a[-1] == root:
            counter[a[-1]] += 1
        if a[-1] - 1 > -1:
            counter[a[-1]] += counter[a[-1] - 1]
        if a[-1] + 1 < n:
            counter[a[-1]] += counter[a[-1] + 1]
        del a[-1]
    return counter

def gap(filt: list[int]) -> list[int]:
    """Reformats lists in a useful way for presenting simple filtrations."""
    out = []
    out.append(filt[0] + 3)
    for j in range(1,len(filt)):
        out.append(filt[j] - filt[j-1] - 1)
    return out

def filtration(dimension_vector: list[int], socle: int) -> list:
    simples = dimension_vector.copy()
    filtration = [[socle]]
    simples[socle - 1] -= 1
    while any(simples):
        counter_list = []
        for j in filtration[-1]:
            if j < len(simples):
                if simples[j] > 0:
                    counter_list.append(j + 1)
            if j > 1:
                if simples[j - 2] > 0:
                    counter_list.append(j - 1)
        indices = set(counter_list)
        layer = sorted([i for i in indices])
        filtration.append(layer)
        for k in layer:
            simples[k - 1] -= 1
    return filtration



def list_to_profile(dimension_vector: list[int], socle: int, print_filt = False) -> str:
    """Given a dimension vector and socle we return the unique preprojective module with
    this presentation. This is true in the case of dimension vectors and socles
    generated by the above algorithm."""
    filtred = filtration(dimension_vector,socle)
    string_out = f' '
    for t in range(len(filtred)-1, -1, -1):
        for j in range(len(filtred[t])):
            string_out += f' '*gap(filtred[t])[j]
            string_out += f'{filtred[t][j]}'
        string_out += '\n '
    if print_filt:
        print(string_out)
    return string_out[:-1]

def tilt_alg_gls(expression: list[int], n: int) -> None:
    """We now implement Leclerc's algorithm by taking sequential subwords of the reduced
    expression for w and applying the above process. This gives a tilting object in C_{w}"""
    total = []
    reversed_expression = expression[::-1]
    for i in range(len(expression)):
        total.append([reflector(reversed_expression[:i+1], n), reversed_expression[i]])
    for j in total:
        print(list_to_profile(j[0], j[1]))
        print('-----------------------------------------------------------')

import numpy as np
def top(presentation: np.ndarray) -> list:
    """Given a matrix representing a simple filtration we find the positions we allow to be removed by epsilon."""
    k = presentation.shape[0] + presentation.shape[1] - 2
    tops = []
    while k > -1:
        pairing = [[i,k-i] for i in range(k+1)]
        for i in range(len(pairing)-1,-1,-1):
            if pairing[i][0] not in range(presentation.shape[0]):
                del pairing[i]
            elif pairing[i][1] not in range(presentation.shape[1]):
                del pairing[i]
        for i in pairing:
            above = np.copy(presentation[i[0]:, i[1]:])
            above[0,0] = 0
            if not above.any():
                if presentation[i[0]][i[1]] != 0:
                    tops.append(i)
        k -= 1
    return tops

def mat_to_list_conv(filt: np.ndarray) -> list:
    """The previous function returns a numpy array so here we convert it to a list
    for use in list_to_profile."""
    dim = [0 for _ in range(filt.shape[0] + filt.shape[1] - 1)]
    for i in range(filt.shape[1]):
        for j in range(filt.shape[0]):
            dim[filt.shape[0] + i - j - 1] += 1*filt[j][i]
    return dim

def profile_decorator(func):
    def wrapper(w_expression: list[int], n: int) -> list:
        counter = []
        for j in func(w_expression, n):
            counter.append(mat_to_list_conv(j))
        for j in counter:
            list_to_profile(j, counter.index(j) + 1, print_filt=True)
        return counter
    return wrapper

@profile_decorator
def epsilon(w_expression: list[int], n: int) -> list:
    """Given a reduced expression for w we return the string as above giving
    the filtration of the projective-injectives after applying epsilon.
    WARNING: Leclerc often applies w^{-1}w_0 rather than w. This requires
    the user to compute a reduced expression for w^{-1}w_0 before using this function."""
    Epsilon = []
    Projectives = []
    for i in range(n):
        P = np.ones([i+1,n-i])
        Projectives.append(P)
    for P in Projectives:
        expression = w_expression.copy()
        while len(expression) > 0:
            head = top(P)
            g = lambda x: P.shape[0] + x[1] - x[0]
            for t in head:
                if g(t) == expression[-1]:
                    P[t[0],t[1]] = 0
            del expression[-1]
        Epsilon.append(P)
    return Epsilon

def index_to_perm(index: list[int], n: int) -> list[int]:
    per = []
    k = len(index)
    for i in range(k-1, -1, -1):
        per += [i for i in range(index[-1], n - k + i + 2)]
        del index[-1]
    return per

def main(W_expression: list[int], v: list[int], n: int) -> None:
    """Given a reduced expression for w and a k-index v giving rise to a Grassmannian
    Richardson variety we implement an alogrithm to produce a tilting module in Leclerc's
    C_{w}. This then must be quotiented by the maximal submodule in C_{v}. We construct the module
    whose factors give C_{v}. This speeds up the process of computing tilting objects in Leclerc's
    categorification when v = w^{K}_0 u for W^{K} parabolic associated to a Grassmannian and
    u in W^{K}\W."""
    print('First we produce the cluster-tilting object in C_w \n')
    tilt_alg_gls(W_expression, n, verbose=True)
    print(f'Each summand must then be quotiented by a maximal submodule which is a factor of the following module:')
    epsilon(index_to_perm(v, n), n)

W_expression = [2, 1, 2, 6, 5, 6, 4, 5, 6, 3, 2, 4, 1, 3, 5, 2, 4, 6, 3, 5]
v = [1, 3, 5]
n = 6

if __name__ == '__main__':
    main(W_expression, v, n)


