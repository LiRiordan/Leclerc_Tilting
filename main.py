### We include several other functions for dealing with permutations

def simple_to_perm(expression: list[int], n: int) -> list[int]:
    '''Takes a simple expression in format list[int], and the number n with the
    permutation of n letters and returns the corresponding permutation giving the bottom row of the
    permutation in list[int] format.'''
    out = [i+1 for i in range(n)]
    for j in expression:
        out = out[:j-1] + [out[j]] + [out[j-1]] + out[j+1:]
    return out


def flip(perm: list[int], n: int) -> list[int]:
    '''Equivalent to sending a permutation, perm, to w_0 perm.'''
    for i in range(len(perm)):
        perm[i] = n+1 - perm[i]
    return perm


a = [4,3,2,1,4,3,2,7,6,5,4,3,8,6,4,10,9,8,7,6,5,11,10,9,8,7]
b = [4,3,2,1,5,4,3,2,7,6,5,4,3,8,7,6,5,4,10,9,8,7,6,5,11,10,9,8,7,6]


def long_1(exp: list[int], k: int) -> list[int]:
    '''Equivalent to multiplying on the left by w^{K}_0.'''
    return exp[:k][::-1] + exp[k:][::-1]


def long_2(exp: list[int], k: int) -> list[int]:
    '''Equivalent to multiplying on the right by w^{K}_0.'''
    run = [i+1 for i in range(len(exp))]
    run = long_1(run, k)
    run_dict = {i + 1: run[i] for i in range(len(run))}
    return [run_dict[i] for i in long_1(exp, k)]


def inv(exp: list[int]) -> list[int]:
    inv_dict = {exp[i]: i+1 for i in range(len(exp))}
    return [inv_dict[j+1] for j in range(len(exp))]


def niave_expression(perm: list[int], n: int) -> list[int]:
    '''Niave algorithm for producing a simple expression for a permutation.'''
    t = []
    j = [i+1 for i in range(12)]
    for i in j[::-1]:
        if simple_to_perm(t, n)[i-1] == perm[i-1]:
            pass
        else:
            t += [i for i in range(simple_to_perm(t, 12).index(perm[i-1]) + 1, i)]
    return t



def main_2(exp: list[int], n:int) -> list[int]:
    '''Converts the types of simple expressions used in positroid varieties
    by Galashin and Lam into a simple expression for positroid varieties
    in the notation of Leclerc.'''
    a = simple_to_perm(exp, n)
    b = inv(a)
    c = flip(b, n)
    return niave_expression(c, 12)


### Commented out example.
# f = main_2([4,3,2,1,5,4,3,2,7,6,5,4,3,8,7,6,5,4,10,9,8,7,6,5,11,10,9,8,7,6],12)
# print(f)
# print(simple_to_perm(f,12))
# print(len(f))
# g = main_2([4,3,2,1,4,3,2,7,6,5,4,3,8,6,4,10,9,8,7,6,5,11,10,9,8,7],12)
# print(g)
# print(simple_to_perm(g, 12))
# print(len(g))








def reflector(expression: list[int], n: int) -> list[int]:
    """We follow the algorithm in the Leclerc paper on cluster structures in
    strata of Grassmannians and treat a:list[int] as the indices for a reduced
    expression of the permutation w.
    We start by considering the fundamental weight omega_a[-1]. We then act by the reflection a[-1].
    This gives omega_a[-1] + alpha_a[-1].
    We then delete a[-1] and apply the new a[-1] to this sum as a reflection until the list is empty.
    We assume we are in type A. The integer n records the number of vertices.
    """
    a = expression.copy()
    for i in range(len(a)):
        a[i] -= 1
    root = a[-1]
    counter = [0 for _ in range(n)]
    while len(a) > 0:
        counter[a[-1]] = -counter[a[-1]]
        if a[-1] == root:
            counter[a[-1]] += 1
        if a[-1] - 1 > -1:
            counter[a[-1]] += counter[a[-1] - 1]
        if a[-1] + 1 < n:
            counter[a[-1]] += counter[a[-1] + 1]
        del a[-1]
    return counter

def gap(filt: list[int]) -> list[int]:
    """Reformats lists in a useful way for presenting simple filtrations."""
    out = []
    out.append(filt[0] + 3)
    for j in range(1,len(filt)):
        out.append(filt[j] - filt[j-1] - 1)
    return out

def filtration(dimension_vector: list[int], socle: int) -> list:
    simples = dimension_vector.copy()
    filtration = [[socle]]
    simples[socle - 1] -= 1
    while any(simples):
        counter_list = []
        for j in filtration[-1]:
            if j < len(simples):
                if simples[j] > 0:
                    counter_list.append(j + 1)
            if j > 1:
                if simples[j - 2] > 0:
                    counter_list.append(j - 1)
        indices = set(counter_list)
        layer = sorted([i for i in indices])
        filtration.append(layer)
        for k in layer:
            simples[k - 1] -= 1
    return filtration



def list_to_profile(dimension_vector: list[int], socle: int, print_filt = False) -> str:
    """Given a dimension vector and socle we return the unique preprojective module with
    this presentation. This is true in the case of dimension vectors and socles
    generated by the above algorithm."""
    filtred = filtration(dimension_vector,socle)
    string_out = f' '
    for t in range(len(filtred)-1, -1, -1):
        for j in range(len(filtred[t])):
            string_out += f' '*gap(filtred[t])[j]
            string_out += f'{filtred[t][j]}'
        string_out += '\n '
    if print_filt:
        print(string_out)
    return string_out[:-1]

def tilt_alg_gls(expression: list[int], n: int) -> None:
    """We now implement Leclerc's algorithm by taking sequential subwords of the reduced
    expression for w and applying the above process. This gives a tilting object in C_{w}"""
    total = []
    reversed_expression = expression[::-1]
    for i in range(len(expression)):
        total.append([reflector(reversed_expression[:i+1], n), reversed_expression[i]])
    for j in total:
        print(list_to_profile(j[0], j[1]))
        print('-----------------------------------------------------------')

import numpy as np
def top(presentation: np.ndarray) -> list:
    """Given a matrix representing a simple filtration we find the positions we allow to be removed by epsilon."""
    k = presentation.shape[0] + presentation.shape[1] - 2
    tops = []
    while k > -1:
        pairing = [[i,k-i] for i in range(k+1)]
        for i in range(len(pairing)-1,-1,-1):
            if pairing[i][0] not in range(presentation.shape[0]):
                del pairing[i]
            elif pairing[i][1] not in range(presentation.shape[1]):
                del pairing[i]
        for i in pairing:
            above = np.copy(presentation[i[0]:, i[1]:])
            above[0,0] = 0
            if not above.any():
                if presentation[i[0]][i[1]] != 0:
                    tops.append(i)
        k -= 1
    return tops

def mat_to_list_conv(filt: np.ndarray) -> list:
    """The previous function returns a numpy array so here we convert it to a list
    for use in list_to_profile."""
    dim = [0 for _ in range(filt.shape[0] + filt.shape[1] - 1)]
    for i in range(filt.shape[1]):
        for j in range(filt.shape[0]):
            dim[filt.shape[0] + i - j - 1] += 1*filt[j][i]
    return dim

def profile_decorator(func):
    def wrapper(w_expression: list[int], n: int) -> list:
        counter = []
        for j in func(w_expression, n):
            counter.append(mat_to_list_conv(j))
        for j in counter:
            list_to_profile(j, counter.index(j) + 1, print_filt=True)
        return counter
    return wrapper

@profile_decorator
def epsilon(w_expression: list[int], n: int) -> list:
    """Given a reduced expression for w we return the string as above giving
    the filtration of the projective-injectives after applying epsilon.
    WARNING: Leclerc often applies w^{-1}w_0 rather than w. This requires
    the user to compute a reduced expression for w^{-1}w_0 before using this function."""
    Epsilon = []
    Projectives = []
    for i in range(n):
        P = np.ones([i+1,n-i])
        Projectives.append(P)
    for P in Projectives:
        expression = w_expression.copy()
        while len(expression) > 0:
            head = top(P)
            g = lambda x: P.shape[0] + x[1] - x[0]
            for t in head:
                if g(t) == expression[-1]:
                    P[t[0],t[1]] = 0
            del expression[-1]
        Epsilon.append(P)
    return Epsilon

def index_to_perm(index: list[int], n: int) -> list[int]:
    per = []
    k = len(index)
    for i in range(k-1, -1, -1):
        per += [i for i in range(index[-1], n - k + i + 2)]
        del index[-1]
    return per

def main(W_expression: list[int], v: list[int], n: int) -> None:
    """Given a reduced expression for w and a k-index v giving rise to a Grassmannian
    Richardson variety in Gr(k,n+1) we implement an alogrithm to produce a tilting module in Leclerc's
    C_{w}. This then must be quotiented by the maximal submodule in C_{v}. We construct the module
    whose factors give C_{v}. This speeds up the process of computing tilting objects in Leclerc's
    categorification when v = w^{K}_0 u for W^{K} parabolic associated to a Grassmannian and
    u in W^{K}\W."""
    print('First we produce the cluster-tilting object in C_w \n')
    tilt_alg_gls(W_expression, n)
    print(f'Each summand must then be quotiented by a maximal submodule which is a factor of the following module:')
    epsilon(index_to_perm(v, n), n)


W_expression = [6, 7, 8, 9, 10, 11, 4, 5, 6, 7, 8, 9, 10, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8,
                1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 5, 1, 2, 3, 4, 1, 3]
v = [1, 2, 4, 5, 7, 8]
n = 11

# if __name__ == '__main__':
#     main(W_expression, v, n)

